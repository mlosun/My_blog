
[{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/","section":"「少折腾，多记录」","summary":"","title":"「少折腾，多记录」","type":"page"},{"content":" 启动时切换到指定目录 # 对于 zsh 用户\n打开终端。\n输入以下命令来编辑你的 .zshrc 文件（如果不存在，这个命令会创建一个）：\nnano ~/.zshrc 在打开的文件中，添加以下行来设置你的工作目录：\ncd /path/to/your/directory #替换成你想要切换到的目录路径。 保存并关闭文件（在 nano 编辑器中，使用 Ctrl + X，然后按 Y，最后按 Enter）。\n为了让更改生效，你需要重新加载 .zshrc，可以输入以下命令：\nsource ~/.zshrc 这样，每次你打开终端时，它就会自动切换到你指定的目录。如果你使用的是其他 shell，步骤类似，只需找到对应的配置文件进行修改即可。\n终端显示完整路径 # 对于 zsh 用户\n打开终端。\n输入以下命令来编辑你的 .zshrc 文件：\nnano ~/.zshrc 在文件中添加或修改 PROMPT 变量，如下所示：\nPROMPT=\u0026#39;%~ %# \u0026#39; 这里 %~ 代表当前目录的完整路径，%# 是提示符。如果你想要显示当前目录的最后一个部分，可以使用：\nPROMPT=\u0026#39;%1~ %# \u0026#39; 保存并关闭文件。\n重新加载 .zshrc：\nsource ~/.zshrc 使用 python 运行 python3 # 当前 MacOS 版本 13.6.9，没有默认的 python（即终端内使用 python 会返回 zsh: command not found: python），只能使用 python3 来运行。\n很多在其他地方复制的命令是 python 而非 python3，导致经常需要手动去改，有点麻烦。\n打开 .bash_profile 文件\nnano ~/.bash_profile 添加内容（设置别名）\nalias python=\u0026#39;python3\u0026#39; 保存并关闭文件。\n重新加载配置文件\nsource ~/.bash_profile ","date":"2024-10-27","externalUrl":null,"permalink":"/posts/macos-terminal-tips/","section":"文章","summary":"","title":"Mac 终端技巧合集","type":"posts"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/tags/macos/","section":"标签","summary":"","title":"MacOS","type":"tags"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/tags/","section":"标签","summary":"","title":"标签","type":"tags"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/categories/","section":"分类","summary":"","title":"分类","type":"categories"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/tags/%E6%8A%80%E5%B7%A7/","section":"标签","summary":"","title":"技巧","type":"tags"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF/","section":"分类","summary":"","title":"技术","type":"categories"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":"","date":"2024-10-27","externalUrl":null,"permalink":"/tags/%E7%BB%88%E7%AB%AF/","section":"标签","summary":"","title":"终端","type":"tags"},{"content":"","date":"2024-10-18","externalUrl":null,"permalink":"/tags/python/","section":"标签","summary":"","title":"Python","type":"tags"},{"content":"","date":"2024-10-18","externalUrl":null,"permalink":"/categories/python/","section":"分类","summary":"","title":"Python","type":"categories"},{"content":" 需求场景 # 在写量化交易程序的过程中，往往需要多次回测以验证策略及程序的可靠性。由于一些特别的原因，实盘时我需要从数据库去获取相应的参数，而回测时如果也从数据库拿参数，那就会很繁琐，所以我希望能在本地调试参数。\n所以就期望有一种方法，就期望有一种方法，能够在不改变任何代码（包括参数）的情况下分别执行不同参数的回测、实盘代码。\n于是想到了使用不同的文件入口，比如 strategy.py 是实盘模式的运行入口，backtest.py 是回测模式的运行入口。\n但是这样就产生一个问题，当我业务逻辑调整（目前在调试阶段还是比较频繁的）时，两个文件都需要同时去改，这样又是就需要花大量的时间去“找不同”。\n但如果这两个入口文件，在调用同一个函数却能实现不同效果，那就完美了。\n解决方案 # 在对比了 AI 给到的 N 种方案后（有一些方案限于我 python 水平一般，还无法理解），最终我选取了好理解、好操作的方案，在这里记录一下。\n我有三个文件，分别是 strategy.py、backtest.py 、config.py，其中 config.py 是参数模块，负责输出参数，剩下两个是负责实盘和回测的入口文件\n两个入口文件 strategy.py 和 backtest.py 的代码如下（两个文件代码完全相同）：\nimport os from config import 获取参数 入口文件名 = os.path.basename(__file__) 参数 = 获取参数(入口文件名) print(参数) 参数模块 config.py 的代码如下\ndef 获取参数(入口文件名): if 入口文件名 == \u0026#34;strategy.py\u0026#34;: # 实际代码略 参数 = 1 elif 入口文件名 == \u0026#34;backtest.py\u0026#34;: # 实际代码略 参数 = 2 return 参数 这样就能实现\n运行 strategy.py 时，参数 = 1 运行 backtest.py 时，参数 = 2 ","date":"2024-10-18","externalUrl":null,"permalink":"/posts/python-func-diff-entry-and-effects/","section":"文章","summary":"","title":"Python 不同入口文件调用同一函数实现不同效果","type":"posts"},{"content":"","date":"2024-10-18","externalUrl":null,"permalink":"/tags/%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/","section":"标签","summary":"","title":"入口文件","type":"tags"},{"content":" 大纲隐藏变量 # 打开设置页 cmd+,，搜索 outline.showVariables，取消勾选即可\n","date":"2024-10-17","externalUrl":null,"permalink":"/posts/vscode-tips/","section":"文章","summary":"","title":"VS Code 技巧合集","type":"posts"},{"content":"","date":"2024-10-17","externalUrl":null,"permalink":"/tags/vs_code/","section":"标签","summary":"","title":"VS_Code","type":"tags"},{"content":"","date":"2024-10-08","externalUrl":null,"permalink":"/tags/1panel/","section":"标签","summary":"","title":"1Panel","type":"tags"},{"content":" 本文写于 2024 年 10 月 8 日，后续会将此问题报告给京东云客服，期待解决～\n情况说明 # 自己一直在使用腾讯云。前几个月频繁看到京东云的小广告，了解了一下是价格是真香，于是 50 元/年入手了这台位于宿迁的 2H2G3M 的京东轻量云。\n今天打算重装下系统，安装 1Panel 面板，选择了 Debian 12.5.0 镜像。\n系统重装好后，输入 1Panel 在 Debian 上的一键安装命令后按提示继续，最终出现报错：\nE: The repository \u0026#39;cdrom://[Debian GNU/Linux 12.5.0 _Bookworm_ - Official amd64 DVD Binary-1 with firmware 20240210-11:28] bookworm Release\u0026#39; does not have a Release file. E: The repository \u0026#39;http://mirrors.jdcloudcs.com/debian bookworm Release\u0026#39; no longer has a Release file. E: The repository \u0026#39;http://mirrors.jdcloudcs.com/debian-security bookworm-security Release\u0026#39; no longer has a Release file. E: The repository \u0026#39;http://mirrors.jdcloudcs.com/debian bookworm-updates Release\u0026#39; no longer has a Release file. [1Panel Log]: docker 安装失败 您可以尝试使用离线包进行安装，具体安装步骤请参考以下链接：https://1panel.cn/docs/installation/package_installation/ 最终导致无法安装 1Panel 面板。\n尝试解决 # 作为技术小白，很庆幸现在 AI 技术的发达，于是向 AI 发起求助。\nAI 告诉我使用命令 nano /etc/apt/sources.list 编辑软件源列表，将上面的 cdrom 行注释掉，再将下面三行的的京东云的源换成阿里云（即 jdcloudcs 换成 aliyun），再执行 apt-get update 更新，就可以解决问题。\n手动尝试了下，果然可以了。\n一键脚本 # 不过这个手动修改对于不擅长使用终端编辑文件的我还是有点麻烦的，干脆让 AI 来帮忙写个一键脚本，然后再重装一次系统试了下，完美解决～\nsed -i \u0026#39;/^deb cdrom/s/^/#/; s/jdcloudcs/aliyun/g\u0026#39; /etc/apt/sources.list \u0026amp;\u0026amp; apt-get update 脚本解释：\n这个脚本的作用是对 /etc/apt/sources.list 文件进行编辑和更新软件包信息。以下是脚本执行的步骤：\n注释掉以 deb cdrom 开头的行： 使用 sed -i '/^deb cdrom/s/^/#/' /etc/apt/sources.list，将文件中以 deb cdrom 开头的行用 # 注释掉。这一操作使得这些行在包管理时被忽略。 替换源地址中的 jdcloudcs 为 aliyun： 使用 sed -i 's/jdcloudcs/aliyun/g' /etc/apt/sources.list，将所有包含 jdcloudcs 的地方替换为 aliyun。这通常用于更改软件源地址。 更新软件包索引： 使用 apt-get update 来更新软件包索引，以便系统知道软件源中的最新软件包信息。 ","date":"2024-10-08","externalUrl":null,"permalink":"/posts/jdcloud-1panel-error/","section":"文章","summary":"","title":"解决京东轻量云主机 Debian 12.5.0 镜像无法安装 1Panel 的问题","type":"posts"},{"content":"","date":"2024-10-08","externalUrl":null,"permalink":"/categories/%E6%8A%98%E8%85%BE/","section":"分类","summary":"","title":"折腾","type":"categories"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/tags/docker/","section":"标签","summary":"","title":"Docker","type":"tags"},{"content":" 2024-10-08 update 昨天折腾好了远程管理 docker 后不久，发现远程主机里莫名出现了一个名为 boorish_agelast 运行 ubuntu:18.04 的容器，经过一番搜索了解到这是一种 针对 Docker 守护进程的加密劫持蠕虫\n同时云服务器也收到了恶意文件通知：\n然后了解到使用 Docker API 时可以通过 TLS 进行加密连接，不过看起来似乎有点麻烦，想着自己的 Docker 目前还没有多到非要集中管理的地步，就先找两篇文章搁置在这里吧。\n如何开启 Docker Remote API 的 TLS 认证，并在 Portainer 上进行配置 Docker启用TLS进行安全配置 - JadePeng - 博客园 本文内容基于 6053537/portainer-ce - Docker Image | Docker Hub 的汉化版。\n远程主机设置 # 首先要已经安装 Docker，这个自然不必说。\n进入主机终端，输入命令：\nnano /usr/lib/systemd/system/docker.service 然后做以下修改：\n# 将这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock # 改为这样 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock 最后再重启 Docker 即可\nsystemctl daemon-reload systemctl restart docker 记得在服务器的防火墙放开 2375 端口\nPortainer 设置 # 环境 - 添加环境 - 独立的 Docker 选择 API 连接模式 Docker API URL 处填写被远程连接的主机 IP+ 端口，如 6.6.6.6:2375 点击链接，完成。 参考 # 部署 Portainer 来管理本地或远程的 Docker - Moeyukina\u0026rsquo;s Blog\n","date":"2024-10-07","externalUrl":null,"permalink":"/posts/portainer-manage-docker/","section":"文章","summary":"","title":"使用 Portainer 远程管理 Docker","type":"posts"},{"content":"","date":"2024-10-06","externalUrl":null,"permalink":"/tags/pipreqs/","section":"标签","summary":"","title":"Pipreqs","type":"tags"},{"content":"pipreqs 是一个 Python 库，它的主要功能是根据项目代码中的 import 语句自动生成 requirements.txt 文件。这个文件列出了项目所依赖的第三方库和版本，便于环境的重现和部署。\n安装 # 你可以通过以下命令来安装 pipreqs：\npip install pipreqs 用法 # 安装好后就可以在项目根目录下通过如下命令生成 requirements.txt 文件。\npipreqs . --encoding=utf-8 --force 选项 # \u0026lt;path\u0026gt;: 指定要扫描的目录路径，如果未提供，则默认使用当前目录。 --use-local: 仅从本地安装的库中获取版本信息，而不通过 PyPI 远程查找。 --pypi-server \u0026lt;url\u0026gt;: 使用自定义的 PyPI 源地址来获取包的信息。 --proxy \u0026lt;url\u0026gt;: 使用代理服务器进行网络请求。代理地址可以直接在命令行指定，或者通过环境变量设置。 --debug: 启用调试模式，输出详细的调试信息。 --ignore \u0026lt;dirs\u0026gt;: 忽略特定的目录，避免在这些目录中查找依赖。多个目录可以用逗号分隔。 --no-follow-links: 如果项目中有符号链接文件夹，pipreqs 默认会跟随这些链接。使用此参数可以禁止这一行为。 --encoding \u0026lt;charset\u0026gt;: 为打开文件指定编码类型（默认是 utf-8）。 --savepath \u0026lt;file\u0026gt;: 自定义生成的 requirements.txt 文件保存路径。 --print: 将依赖项直接输出到终端，而不生成 requirements.txt 文件。 --force: 如果 requirements.txt 文件已经存在，使用此参数强制覆盖。 --diff \u0026lt;file\u0026gt;: 比较指定的 requirements.txt 文件中的依赖与项目实际导入的依赖，查看差异。 --clean \u0026lt;file\u0026gt;: 清理指定的 requirements.txt 文件，移除那些在项目中未实际导入的库。 --mode \u0026lt;scheme\u0026gt;: 指定生成 requirements.txt 文件中依赖的版本控制方式，支持以下三种： compat: 使用兼容版本，如 Flask~=1.1.2，表示兼容 1.1.x 版本。 gt: 使用大于等于版本号的模式，如 Flask\u0026gt;=1.1.2。 no-pin: 不指定版本号，如 Flask。 --scan-notebooks: 在项目的 Jupyter Notebook 文件中查找 import 语句，适合那些使用 .ipynb 文件的项目。 延伸 # 生成 requirements.txt 文件也可以直接使用 pip 的自带命令 pip freeze \u0026gt; requirements.txt，只是这样会将本地环境中的所有三方包都丢进去，通常情况下这并不是我们想要的。\n可以使用如下命令一次性安装 requirements.txt 里的全部包\npip install -r requirements.txt ","date":"2024-10-06","externalUrl":null,"permalink":"/posts/python-pipreqs/","section":"文章","summary":"","title":"Python库：pipreqs 生成项目依赖文件","type":"posts"},{"content":"","date":"2024-09-17","externalUrl":null,"permalink":"/tags/tqsdk/","section":"标签","summary":"","title":"Tqsdk","type":"tags"},{"content":"","date":"2024-09-17","externalUrl":null,"permalink":"/categories/tqsdk/","section":"分类","summary":"","title":"Tqsdk","type":"categories"},{"content":" 合约类型 # 根据 query_symbol_info 得知，Tqsdk 里的合约类型可能的值有：\nFUTURE 期货 CONT 主连 COMBINE 组合 INDEX 指数 OPTION 期权 STOCK 股票 这里常用的就是 FUTURE 和 CONT。\n通常使用 FUTURE 就可以了，但是在做一些长周期的回测时，需要考虑到主力合约变更的情况。官方文档对这个问题的描述 是使用主连合约，然后使用 quote.underlying_symbol 获取回测当时的标的合约。\n在实际应用时，发现 FUTURE 和 CONT 不同合约类型，在订阅 kline、quote、tick 等数据时还是有一些细微区别的，在这里整理并做记录。\n测试代码 # 以下是测试时使用的代码，测试时 CZCE.AP501 是当前主力，且持空仓 13 手。\nfrom tqsdk import TqApi,TqAuth,TqKq api = TqApi(account = TqKq(),auth=TqAuth(\u0026#34;信易账户\u0026#34;,\u0026#34;信易密码\u0026#34;)) FUTURE = \u0026#39;CZCE.AP501\u0026#39; CONT = \u0026#39;KQ.m@CZCE.AP\u0026#39; print(\u0026#39;========== quote ==========\u0026#39;) print(api.get_quote(FUTURE)) print(api.get_quote(CONT)) print(\u0026#39;========== kline ==========\u0026#39;) print(api.get_kline_serial(FUTURE,86400).iloc[0]) print(api.get_kline_serial(CONT,86400).iloc[0]) print(\u0026#39;========== tick ==========\u0026#39;) print(api.get_tick_serial(FUTURE).iloc[0]) print(api.get_tick_serial(CONT).iloc[0]) print(\u0026#39;========== position ==========\u0026#39;) print(api.get_position(FUTURE)) print(api.get_position(CONT)) print(\u0026#39;========== symbol_info ==========\u0026#39;) print(api.query_symbol_info(FUTURE).iloc[0]) print(api.query_symbol_info(CONT).iloc[0]) api.close() 数据差异 # 图片中左侧是 FUTURE，右侧是 CONT\nget_quote 差异 # 接口文档 get_kline_serial 差异 # 接口文档 get_tick_serial 差异 # 接口文档 get_position 差异 # 接口文档 query_symbol_info 差异 # 接口文档 ","date":"2024-09-17","externalUrl":null,"permalink":"/posts/tqsdk-ins_class-diff/","section":"文章","summary":"","title":"TqSdk 不同合约类型的数据差异","type":"posts"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/tags/git/","section":"标签","summary":"","title":"Git","type":"tags"},{"content":" 本文基于的 Git 版本：\ngit version 2.46.0 版本号：2.46.0 操作系统：macOS 64 位 构建时间：2024 年 7 月 29 日 常用命令 # 由于我很少使用命令行进行 Git 操作，所以我常用的命令往往是查询或设置类的命令\n查看 git 版本\ngit -v 用户名和邮箱\n# 设置全局的用户名和邮箱 git config --global user.name \u0026#34;username\u0026#34; git config --global user.email \u0026#34;username@email.com\u0026#34; # 设置当前仓库的用户名和邮箱 git config user.name \u0026#34;username\u0026#34; git config user.email \u0026#34;username@email.com\u0026#34; # 查看当前仓库的用户名和邮箱 git config user.name git config user.email 查看当前配置\ngit config --list 查看当前分支和远程分支\ngit branch -a 查看远程仓库信息\ngit remote -v 查看当前状态（查看哪些文件被修改或暂存）\ngit status 查看文件差异（比较工作目录和暂存区的差异）\ngit diff Git help # 在终端输入 git help，输出以下内容\n用法：git [-v | --version] [-h | --help] [-C \u0026lt;路径\u0026gt;] [-c \u0026lt;名称\u0026gt;=\u0026lt;取值\u0026gt;] [--exec-path[=\u0026lt;路径\u0026gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [\u0026#34;--no-lazy-fetch] [--no-optional-locks] [--no-advice] [--bare] [--git-dir=\u0026lt;路径\u0026gt;] [--work-tree=\u0026lt;路径\u0026gt;] [--namespace=\u0026lt;名称\u0026gt;] [--config-env=\u0026lt;名称\u0026gt;=\u0026lt;环境变量\u0026gt;] \u0026lt;命令\u0026gt; [\u0026lt;参数\u0026gt;] 这些是各种场合常见的 Git 命令： 开始一个工作区（参见：git help tutorial） clone 克隆仓库到一个新目录 init 创建一个空的 Git 仓库或重新初始化一个已存在的仓库 在当前变更上工作（参见：git help everyday） add 添加文件内容至索引 mv 移动或重命名一个文件、目录或符号链接 restore 恢复工作区文件 rm 从工作区和索引中删除文件 检查历史和状态（参见：git help revisions） bisect 通过二分查找定位引入 bug 的提交 diff 显示提交之间、提交和工作区之间等的差异 grep 输出和模式匹配的行 log 显示提交日志 show 显示各种类型的对象 status 显示工作区状态 扩展、标记和调校您的历史记录 branch 列出、创建或删除分支 commit 记录变更到仓库 merge 合并两个或更多开发历史 rebase 在另一个分支上重新应用提交 reset 重置当前 HEAD 到指定状态 switch 切换分支 tag 创建、列出、删除或校验一个 GPG 签名的标签对象 协同（参见：git help workflows） fetch 从另外一个仓库下载对象和引用 pull 获取并整合另外的仓库或一个本地分支 push 更新远程引用和相关的对象 命令 \u0026#39;git help -a\u0026#39; 和 \u0026#39;git help -g\u0026#39; 显示可用的子命令和一些概念帮助。 查看 \u0026#39;git help \u0026lt;命令\u0026gt;\u0026#39; 或 \u0026#39;git help \u0026lt;概念\u0026gt;\u0026#39; 以获取给定子命令或概念的 帮助。 有关系统的概述，查看 \u0026#39;git help git\u0026#39;。 ","date":"2024-09-15","externalUrl":null,"permalink":"/posts/common-git-commands/","section":"文章","summary":"","title":"Git 的常用命令","type":"posts"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/tags/github/","section":"标签","summary":"","title":"Github","type":"tags"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/tags/picgo/","section":"标签","summary":"","title":"PicGo","type":"tags"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/categories/%E6%8A%80%E5%B7%A7/","section":"分类","summary":"","title":"技巧","type":"categories"},{"content":" Github 设置 # 创建 一个新的 Github 仓库 手动创建 CNAME 绑定域名（记得解析） Settings - Pages 中 Branch 设置为 main 勾选 Enforce HTTPS 创建 一个新的 Github Token PicGo 设置 # 下载 并安装 PicGo v2.3.1 截止目前（2024-09-15） 最新的正式版是 v2.3.1 最新的测试版是 v2.4.0-beta.8 图床服务对功能无更多需求，稳定优先，所以使用最新的正式版即可 添加一个 Github 图床 仓库名、分支名、Token 自行填写 设定存储路径：我使用 images/2024/ 设定自定义域名：填写仓库里使用 CNAME 文件绑定的域名 PicGo 设置 开启自启：开 时间戳重命名：开 上传后自动复制 URL：开 其余根据自身喜好设置即可 这样设置后，图片路径将是这样的格式 https://域名/images/2024/202409152129743.jpg 定期维护 # 这个图床我主要在 Hugo 和 Obsidian 中使用，这里有两个考虑点：\n自己在 Obsidian 笔记的过程中会产生一些冗余图片，很久后笔记失效同时对应的图片也会失效 目前使用 Github 作为图床存储，但未来或许会迁移到腾讯云 COS 中，冗余图片会带来不必要的成本 所以我需要有一个定期维护的方案。 这个定期维护的周期，按月太频繁，所以考虑按年维护即可。如前面描述，存储路径被我设置为 images/2024/，到明年的话就会改成 images/2025/ 这样的话每年清理一遍冗余图片即可。\n（这样的方案也比较灵活，结合时间戳重命名，如果在 2025 年年初未能及时重新设置，那么图片路径会变成 images/2024/2025***********.jpg，也能够很方便的找出来）\n应用设置 # Obsidian # 使用插件 Image auto upload\n安装后只需要确保 PicGo server 上传接口地址和端口与 PicGo 设置的一致即可（通常都是默认）\n其余的一些个性化设置：\n剪切板自动上传：开 图片描述：移除 image.png 图片大小后缀：空 应用网络图片：开 上传文件后移除源文件：开 Hugo # 由于我大部分 Hugo 的文章都是通过 Obsidian 完成，所以并不需要做什么特殊的设置。\n只有少量单独的图片需要使用到图床时，手动上传到 blog 目录下即可。\n","date":"2024-09-15","externalUrl":null,"permalink":"/posts/picgo-github/","section":"文章","summary":"","title":"使用 PicGo 和 Github 搭建图床","type":"posts"},{"content":"","date":"2024-09-15","externalUrl":null,"permalink":"/tags/%E5%9B%BE%E5%BA%8A/","section":"标签","summary":"","title":"图床","type":"tags"},{"content":"","date":"2024-09-14","externalUrl":null,"permalink":"/tags/hugo/","section":"标签","summary":"","title":"Hugo","type":"tags"},{"content":" 本文基于的 hugo 版本：\nhugo v0.134.2+extended darwin/amd64 BuildDate=2024-09-10T10:46:33Z VendorInfo=brew 版本号：0.134.2 扩展版 操作系统：macOS 64 位 构建时间：2024 年 9 月 10 日 安装来源：Homebrew 包管理器 常用命令 # 查看 hugo 版本\nhugo version 创建一个新站点，存储在 newblog 文件夹内\nhugo new site newblog 创建一篇新文章，路径为 content/posts/newpost.md\nhugo new posts/newpost.md 本地预览（生成静态文件并启动 web 服务） http://localhost:1313/\nhugo server -w -D hugo help 翻译 # 安装好 hugo 后，在终端输入 hugo help 会输出如下内容：\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at https://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: completion Generate the autocompletion script for the specified shell config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print Hugo version and environment info Flags: -b, --baseURL string hostname (and path) to the root, e.g. https://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory --cleanDestinationDir remove files from destination not found in static directories --clock string set the clock used by Hugo, e.g. --clock 2021-11-06T22:30:00.00+09:00 --config string config file (default is hugo.yaml|json|toml) --configDir string config dir (default \u0026#34;config\u0026#34;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date, author, and CODEOWNERS info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --ignoreCache ignores the cache directory --ignoreVendorPaths string ignores any _vendor for module paths matching the given Glob pattern -l, --layoutDir string filesystem path to layout directory --logLevel string log level (debug|info|warn|error) --minify minify any supported output format (HTML, XML etc.) --noBuildLock don\u0026#39;t create .hugo_build.lock file --noChmod don\u0026#39;t sync permission mode of files --noTimes don\u0026#39;t sync modification time of files --panicOnWarning panic on first WARNING log --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --printI18nWarnings print missing translations --printMemoryUsage print memory usage to screen at intervals --printPathWarnings print warnings on duplicate target paths etc. --printUnusedTemplates print warnings on unused templates. --quiet build in quiet mode --renderSegments strings named segments to render (configured in the segments config) -M, --renderToMemory render to memory (mostly useful when running the server) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output -w, --watch watch filesystem for changes and recreate as needed Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. 借助 AI 对其进行翻译\nHugo 是主命令，用于构建你的 Hugo 网站。 Hugo 是一个快速且灵活的静态网站生成器， 由 spf13 和朋友们用 Go 语言编写，满怀热情打造。 完整的文档可以在 https://gohugo.io/ 上找到。 用法: hugo [flags] hugo [command] 可用命令: completion 为指定的 shell 生成自动补全脚本 config 输出站点配置 convert 将你的内容转换为不同格式 deploy 将你的站点部署到云服务提供商 env 输出 Hugo 版本和环境信息 gen 一些有用的生成器集合 help 获取关于某个命令的帮助 import 从其他平台导入你的站点 list 列出各种类型的内容 mod 各种 Hugo 模块助手 new 为你的站点创建新内容 server 一个高性能的 Web 服务器 version 输出 Hugo 版本和环境信息 选项（Flags）: -b, --baseURL string 主机名 (及路径)，例如 https://spf13.com/ -D, --buildDrafts 包含标记为草稿的内容 -E, --buildExpired 包含过期内容 -F, --buildFuture 包含发布日期在未来的内容 --cacheDir string 文件系统缓存目录的路径 --cleanDestinationDir 从目标目录中移除未在静态目录中找到的文件 --clock string 设置 Hugo 使用的时钟，例如 --clock 2021-11-06T22:30:00.00+09:00 --config string 配置文件 (默认是 hugo.yaml|json|toml) --configDir string 配置目录 (默认 \u0026#34;config\u0026#34;) -c, --contentDir string 内容目录的文件系统路径 --debug 输出调试信息 -d, --destination string 写入文件的文件系统路径 --disableKinds strings 禁用不同类型的页面 (首页, RSS 等) --enableGitInfo 将 Git 版本、日期、作者和 CODEOWNERS 信息添加到页面中 -e, --environment string 构建环境 --forceSyncStatic 静态文件更改时复制所有文件 --gc 启用构建后的清理任务 (移除未使用的缓存文件) -h, --help 获取 Hugo 的帮助信息 --ignoreCache 忽略缓存目录 --ignoreVendorPaths string 忽略与给定 Glob 模式匹配的模块路径中的任何 _vendor -l, --layoutDir string 布局目录的文件系统路径 --logLevel string 日志级别 (debug|info|warn|error) --minify 压缩任何支持的输出格式 (HTML, XML 等) --noBuildLock 不创建 .hugo_build.lock 文件 --noChmod 不同步文件的权限模式 --noTimes 不同步文件的修改时间 --panicOnWarning 在首次出现 WARNING 日志时停止程序 --poll string 设置轮询间隔，例如 --poll 700ms，使用轮询方式监控文件系统变化 --printI18nWarnings 输出缺失的翻译警告 --printMemoryUsage 定期输出内存使用信息 --printPathWarnings 输出重复目标路径等警告 --printUnusedTemplates 输出未使用的模板警告 --quiet 静默模式构建 --renderSegments strings 渲染命名的部分 (在配置中定义) -M, --renderToMemory 渲染到内存 (主要用于运行服务器时) -s, --source string 读取文件的相对路径 --templateMetrics 显示模板执行的指标 --templateMetricsHints 结合 --templateMetrics 使用时计算一些优化提示 -t, --theme strings 使用的主题 (位于 /themes/THEMENAME/) --themesDir string 主题目录的文件系统路径 --trace file 将跟踪信息写入文件 (通常不需要) -v, --verbose 输出详细信息 -w, --watch 监视文件系统的变化并根据需要重新生成 使用 \u0026#34;hugo [command] --help\u0026#34; 获取某个命令的更多信息。 ","date":"2024-09-14","externalUrl":null,"permalink":"/posts/common-hugo-commands/","section":"文章","summary":"","title":"Hugo 的常用命令","type":"posts"},{"content":"","date":"2024-09-12","externalUrl":null,"permalink":"/tags/gihub/","section":"标签","summary":"","title":"Gihub","type":"tags"},{"content":"TODO\n","date":"2024-09-12","externalUrl":null,"permalink":"/about/","section":"关于","summary":"","title":"关于","type":"about"},{"content":" 最近一段时间为了将在不同设备跑的程序日志汇总在一起分析，向 Github 的仓库上传了大量的 log 文件，导致仓库过大在拉取时频繁出错，但其余普通大小的仓库拉取就没问题。所以想着用删除历史提交的方式将仓库变小。\n注意：此操作有风险，需提前做好备份再执行。\n方法一：创建一个新的主分支 # git checkout --orphan latest_branch # 将当前最新代码切换到新分支 git add -A # 暂存当前所有文件 git commit -m \u0026#34;init commit\u0026#34; # 提交暂存的文件 git branch -D main # 删除原有main分支 git branch -m main # 将当前分支重命名为main git push -f origin main # 推送到远端的main分支 方法二：重新初始化 git # # 首先手动删除本地的.git目录 git init # 初始化新的git仓库 git add -A # 暂存当前所有文件 git commit -m \u0026#34;init commit\u0026#34; # 提交暂存的文件 git push -f https://github.com/username/repo.git main # 使用 -f 强制推送到远端main分支 ","date":"2024-09-12","externalUrl":null,"permalink":"/posts/delete-github-commit/","section":"文章","summary":"","title":"删除Github仓库的历史提交记录","type":"posts"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/tags/obsidian/","section":"标签","summary":"","title":"Obsidian","type":"tags"},{"content":" 这是我自己正在使用的工作流，里面参杂了一些不一定通用，但适合自己的配置项，请注意甄别。\n除非我不采取本方案发布笔记了，否则本文将长期更新。\n在 Github 上部署 Hugo # 创建仓库 # 在 Github 上 创建 一个仓库，命名为 blog（可以根据自己喜好命名），记得创建是选择 Public 并且勾选 Add a README file，其余默认即可。\n创建完成后在 Code 按钮下进入 Codespaces 标签页，点击 Create codespace on main 创建一个线上开发环境，也就是一个线上版的 VScode。\n初始化 Hugo 文件 # 然后就可以在这里直接初始化 hugo。当然，有代码洁癖的我决定直接手工进行初始化，接下来的操作均在 Codespaces 的终端中进行。\n安装主题 这里我使用优雅的 MemE 主题（2024/10/27 注：已不再使用 MemE 主题，但此处仍以 MemE 主题为例）\ngit submodule add --depth 1 https://github.com/reuixiy/hugo-theme-meme.git themes/meme 创建配置文件 这里是将主题的默认配置文件复制过来，执行完可以看到目录树已经出现了 config.toml 文件了\ncp themes/meme/config-examples/zh-cn/config.toml config.toml 新建一篇文章 创建文件 content/posts/hello_world.md\nmkdir -p content/posts \u0026amp;\u0026amp; echo -e \u0026#34;---\\ntitle: hello world\\ndate: 2024-09-10\\n---\\nhello world\u0026#34; \u0026gt; content/posts/hello_world.md 新建关于页面 创建文件 content/about/_index.md\nmkdir -p content/about \u0026amp;\u0026amp; echo -e \u0026#34;---\\ntitle: about\\ndate: 2024-09-10\\n---\\nabout\u0026#34; \u0026gt; content/about/_index.md 绑定域名 将 YouDomain.com 和 www.YouDomain.com 改为自己的域名。这里是利用了 Hugo 的 static 目录 特性 ，绑定完成后不要忘记解析域名。\nmkdir -p static \u0026amp;\u0026amp; echo -e \u0026#34;YouDomain.com\\nwww.YouDomain.com\u0026#34; \u0026gt; static/CNAME 保存并提交代码 使用 git 提交代码并推送到远端。或者像在 VScode 里，在右侧边栏的源代码管理处用 git 提交你的代码\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;init hugo\u0026#34; \u0026amp;\u0026amp; git push origin main 这时候目录树的结构应该和下面是一样的\nblog/ ├── content/ │ ├── posts/ │ │ └── hello_world.md │ └── about/ │ └── _index.md ├── static/ │ └── CNAME ├── themes/ │ └── meme/ [省略文件内容] ├── .gitmodules ├── config.toml └── README.md 配置 Github Actions # Hugo 的文件部署提交完毕后，还需要利用 Github Actions 进行自动化部署。\n在 这里 生成一个 Github Token（classic，repo 权限，无有效期）\n在仓库的 Settings → Secrets and variables → Actions 中添加一个 Secret\nName 填入 ACTION_ACCESS_TOKEN Secret 填入刚才生成的 Token 在仓库根目录下创建文件 .github/workflows/Deploy.yml，内容如下\nname: Build and Deploy on: push: branches: - main # 当推送到 main 分支时触发 jobs: build-deploy: runs-on: ubuntu-latest # 运行在最新版本的 Ubuntu 上 steps: - name: Checkout uses: actions/checkout@v4 with: submodules: true # 确保检出子模块 fetch-depth: 0 # 获取完整历史记录 # 检出仓库代码并包含子模块 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true # 设置 Hugo，安装最新版本的 Hugo 扩展版 - name: Update submodules run: git submodule update --init --recursive # 初始化并更新子模块 - name: Build run: hugo # 运行 Hugo 命令构建静态网站 - name: Deploy to GitHub Pages uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.ACTION_ACCESS_TOKEN }} publish_branch: gh-pages publish_dir: ./public # 部署到 gh-pages 分支 # 使用由 GitHub 自动生成的 ACTION_ACCESS_TOKEN 进行身份验证 # 将构建后的 ./public 目录中的文件发布到 gh-pages 分支 提交后过一会，就会发现仓库多了一个 gh-pages 分支，里面是在本地部署后，pubilc 目录里的文件。\n在仓库的 Settings → Pages → Build and deployment 里选择\nSource 选择 Deploy from a branch Branch 选择 gh-pages 记得勾选下面的 Enforce HTTPS 如无意外，等待域名解析完成后，就可以通过域名访问这个 Hugo 站点了。\n后续就是修改配置文件 config.toml 和生产内容的事情了。\n加餐：自动化部署到服务器 # 众所周知，访问 Github 会比较慢，所以有时也想将 Hugo 的源码保存在 Github，而生成的静态文件部署到国内的服务器上，那么可以采取下面的方式。\nssh 登录到服务器，输入命令 ssh-keygen -t rsa -b 4096 -C \u0026quot;your_email@example.com\u0026quot;（改成自己的邮箱）\n一路默认回车后，就可以在 ~/.ssh 目录下看到 id_rsa（私钥）和 id_rsa.pub（公钥）\n首先将公钥里的内容，复制到 ~/.ssh/authorized_keys 文件中\n然后回到 Github 仓库，陆续添加如下 Secret\nSERVER_PATH，服务器上存储静态资源的路径 SERVER_HOST，服务器 IP 地址 SERVER_PORT，服务器 ssh 端口，一般为 22 SERVER_USER，服务器 ssh 用户 SERVER_KEY，前面生成的私钥内容填入这里 在 .github/workflows/Deploy.yml 后面补充：\n- name: Deploy to Server uses: burnett01/rsync-deployments@7.0.1 with: switches: -avzr --delete path: ./public remote_path: ${{ secrets.SERVER_PATH }} remote_host: ${{ secrets.SERVER_HOST }} remote_port: ${{ secrets.SERVER_PORT }} remote_user: ${{ secrets.SERVER_USER }} remote_key: ${{ secrets.SERVER_KEY }} # 通过 ssh 连接服务器，用 rsync 同步文件 # 服务器信息通过 GitHub Secrets 设置 其实部署到 Github 仓库和服务器，主要是最后一步的 Deploy 不同，我看了很多人写的不同的 Actions 命令，基本上部署到 Github Pages 都是用的 peaceiris/actions-gh-pages，而部署到服务器的确是有很多种方法，在这里我也被 ssh key 这个坑阻挠了好久，最终找到了 burnett01/rsync-deployments 才搞定。\n使用 Obsidian 发布 Hugo 内容 # 工作流原理 # 利用 Obsidian 的 Enveloppe 插件，可以将 Obsidian 仓库中 YMAL 区域有 share: true 标记的笔记，上传到 Github 的指定目录下。我这里将上传到 content/posts 目录下 利用 Obsidian 的 Templater 插件，根据 Enveloppe、Hugo、MemE 主题等特性，创建设定好 YAML 区域的模板，后续直接 Enveloppe 设置 # Github config API Type：APY 类型 Github username：用户名 Repository name：仓库名 GitHub token：可以与前面部署 Hugo 自动化的 Token 共用，也可以生成新的 Main branch：md 源码上传到哪个分支，我是 main Automatically merge pull requests：是否自动合并，我是 true File paths File tree in repository：仓库中的文件树 Fixed Folder Root folder：默认目录，我是 content/posts 上面这些是保障插件可以正常运转的一些设置，其余的内容根据自身喜好即可。\nTemplater 模板 # 创建一个 Templater 模板，内容是常用的文章 Front matter，用于快速插入。详细的选项可以在 Hugo 文档 或者 主题的文档 处查看。\nshare: # Enveloppe 插件允许上传的开关 一般为true date: # 发布日期 格式参考：2024-09-12 lastmod: # 修改日期 格式参考：2024-09-12 tags: # 标签 格式参考：[\u0026#34;Hugo\u0026#34;, \u0026#34;Obsidian\u0026#34;, \u0026#34;Github\u0026#34;, \u0026#34;发布\u0026#34;] categories: # 分类 格式参考：[\u0026#34;折腾\u0026#34;] title: # 文章标题 slug: # 路径标识 发布流程 # 在 Obsidian 中创建笔记，插入刚创建的模板。然后如往常一样使用 obsidian 完善笔记内容即可。\n完成文章内容后，在 Obsidian 文件列表中，右键 Upload 上传到 Github\n稍等 Github Actions 运行完毕，即可访问～\n","date":"2024-09-10","externalUrl":null,"permalink":"/posts/obsidian-github-hugo/","section":"文章","summary":"","title":"Obsidian + Github + Hugo 一站式笔记发布工作流","type":"posts"},{"content":"","date":"2024-09-10","externalUrl":null,"permalink":"/tags/%E5%8F%91%E5%B8%83/","section":"标签","summary":"","title":"发布","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]